<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Vue 인스턴스 생성과 Vue 라이프 사이클</title>
    <link rel="favicon" href="favicon.ico">
</head>
<body>
    <div id="app">
        <!--
            인스턴트의 data 속성의 message 속성값으로 치환
        -->
        {{ message }}
    </div>
    <!--
        여기에
        {{ message }}
        를 두면 인스턴스의 유효범위를 벗어나므로 단순히 위 내용이 그대로 찍히게 된다.
    -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.5.5/dist/vue.js"></script>
    <script>
        //Vue 인스턴스 생성과 Vue 라이프 사이클
        /*
        뷰 인스턴스 라이프 사이클
        - 라이프 사이클(life cyecle) : 뷰 인스턴스의 상태에 따라 호출할 수 있는 속성들. 모바일 앱을 비롯하여 일반적으로 애플리케이션이 가지는 생명 주기
        - 훅(hook) : 각 라이프 사이클 속성에서 실행되는 커스텀 로직. 개발자가 임의로 작성한 추가 로직 
        

        - [인스턴스 생성]: new Vue();
        - beforeCreate : [data 속성과 methods 속성이 아직 인스턴스에 정의되어 있지 않고, 돔과 같은 화면 요소에도 접근 불가능.]
        - created : [data 속성과 method 속성 정의됨]. this.data 또는 this.fetchData()와 같은 로직이용하여 data속성과 methods속성에 정의된 값에 접근하여 로직 실행 가능. 단, [인스턴스가 화면요소에 부착되기 전이기 때문에 template 속성에 정의된 돔 요소 접근 불가]. data속성과 methods속성에 접근할 수 있는 가장 첫 라이프 사이클 단계이자 [컴포넌트가 생성되고나서 실행되는 단계이기 때문에] [서버에 데이터를 요청하여 받아오는 로직을 수행하기 좋음](서버에 데이터를 요청하는 HTTP 통신 등). 
        - beforeMount : template 속성에 지정한 마크업 속성을 render()함수로 변환한 후 el 속성에 지정한 화면요소(돔)에 인스턴스를 부착하기 전에 호출되는 단계. [render() 함수가 호출되기 직전의 로직을 추가하기 좋음]
        - mounted : el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출되는 단계. template 속성에 정의한 화면 요소(돔)에 접근 가능하므로 [요소를 제어하는 로직을 수행하기 좋은 단계]. 돔에 인스턴스가 부착되자마자 바로 호출되기 떄문에 하위 컴포넌트나 외부 라이브러리에 의해 추가된 화면 요소들이 최종 HTML 코드로 변환되는 시점과 다를 수 있음. [변환되는 시점이 다를 경우 ??$next Tick()?? API 를 활용하여 HTML 코드로 최종 파싱될 떄까지 기다린 후 돔 제어로직을 추가]
        - [인스턴스를 화면에 부착] -> 인스턴스에 정의한 속성들이 화면에 치환되며, 치환된 값은 뷰의 반응성(Reactivity)을 제공하기 위해 $watch 속성으로 감시한다. 이를 [데이터 관찰]이라고 한다..*(뷰의 반응성은 뷰의 특징 중 하나로, 코드의 변화에 따라 화면이 반사적으로 반응하여 빠르게 화면을 갱신하는 것을 의미한다.)
        - beforeUpdate : 관찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계이며, 변경 예정인 새 데이터에 접근할 수 있어 [변경 예정 데이터의 값과 관련된 로직을 미리 넣을수 있다]. 여기에 값을 변경하는 로직을 넣더라도 화면이 다시 그려지진 않는다.
        - updated : 데이터가 변경되고 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계. 데이터 변경으로 인한 화면 요소변경까지 완료된 시점이므로, 데이터 변경 후 [화면 요소 제어와 관련된 로직을 추가하기 좋은 단계]. [이 단계에서 데이터 값을 변경하면 무한 루프에 빠질 수 있기 때문에 값을 변경하려면 computed, watch 와 같은 속성을 사용해야한다.] 따라서 [데이터 값을 갱신하는 로직은 가급적이면 beforeUpdate에 추가]하고, updated에서는 [변경ㄷ데이터의 화면 요소와 관련된 로직을 추가하는 것이 좋다.]
        - [인스턴스 내용 갱신]
        - beforeDastroy : 뷰 인스턴스가 파괴되기 직전에 호출되는 단계.[뷰 인스턴스의 데이터를 삭제하기 좋다.]
        - destroyed : 뷰 인스턴스가 파괴되고 호출되는 단계. 모든 속성 제거 및 하위에 선언한 인스턴스들 또한 모두 파괴됨.
        */
        /*
        render()함수 : js 로 화면의 돔을 그리는 함수
        */
        /*
        ??
        $next tick() APi
        https://kr.vuejs.org/v2/api/#Vue-nextTick 
        참조
        */
        new Vue({
            el: "#app",
            data: {
                message: 'Hello Vue.js!'
            },
            beforeCreate: function(){
                console.log("beforeCreate");
            },
            created: function(){
                console.log("created");
            },
            mounted: function(){
                console.log("mounted");
                this.message = "Hello Vue!"
            },
            updated: function(){
                console.log("updated");
            }
        })
    </script>
</body>
</html>